var documenterSearchIndex = {"docs":
[{"location":"#OceanTTDs","page":"Home","title":"OceanTTDs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for OceanTTDs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A Julia package for Transit Time Distribution (TTD) modeling and tracer inversion in oceanography","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OceanTTDs.jl provides a comprehensive toolkit for analyzing ocean tracer distributions using Transit Time Distributions (TTDs). The package implements multiple optimization methods including Time-Corrected Method (TCM), Maximum Entropy (MaxEnt), and Inverse Gaussian fitting for estimating water mass age distributions from tracer observations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Transit Time Distributions: Inverse Gaussian TTD modeling with flexible parameterization\nMultiple Inversion Methods: Inverse Gaussian parameter fitting, Time-Corrected Method (TCM), Maximum Entropy inversion\nNumerical Integration: Adaptive quadrature methods optimized for convolution operations  \nStatistical Utilities: Covariance estimation and regularization methods","category":"page"},{"location":"#Main-Functions","page":"Home","title":"Main Functions","text":"","category":"section"},{"location":"#Data-Structures","page":"Home","title":"Data Structures","text":"","category":"section"},{"location":"#OceanTTDs.TracerObservations.TracerObservation","page":"Home","title":"OceanTTDs.TracerObservations.TracerObservation","text":"TracerObservation{T,F<:Function}\n\nContainer for tracer observation data including measurement values, uncertainties, and source functions.\n\nFields\n\nt_obs::Vector{T}: Time points of observations\ny_obs::Vector{T}: Observed tracer concentrations\nσ_obs::Union{Nothing,Vector{T}}: Measurement uncertainties (optional)\nf_src::Union{Nothing,F}: Source function for boundary conditions (required for inversion)\nnobs::Int: Number of observations\n\nConstructor\n\nTracerObservation(t_obs, y_obs; σ_obs=nothing, f_src=nothing)\n\n\n\n\n\n","category":"type"},{"location":"#OceanTTDs.InversionResults.InversionResult","page":"Home","title":"OceanTTDs.InversionResults.InversionResult","text":"InversionResult{T}\n\nFlexible container for inversion/optimization results that can handle different types of distributions and integration contexts.\n\nFields\n\nparameters::AbstractVector: Estimated parameters. Interpretation depends on method:\n:inverse_gaussian: [Γ, Δ] \n:inverse_gaussian_equalvars: [Γ]\n:max_entropy: λ₁, λ₂, ..., λₙ\nobs_estimates::Vector{TracerEstimate{T}}: Updated TracerEstimate objects with predictions\ndistribution::Union{Distribution, AbstractVector{<:Distribution}, Function, Nothing}: Fitted distribution(s) or template function\nintegrator::Union{Nothing, Any}: Integration method/context used\nsupport::Union{Nothing, AbstractVector}: Discrete support points if applicable\nmethod::Symbol: Method used (e.g., :inversegaussian, :maxentropy, :inversegaussianequalvars)\noptimizer_output: Raw optimization results from the solver\n\n\n\n\n\n","category":"type"},{"location":"#Optimization-Methods","page":"Home","title":"Optimization Methods","text":"","category":"section"},{"location":"#OceanTTDs.Optimizers.invert_inverse_gaussian","page":"Home","title":"OceanTTDs.Optimizers.invert_inverse_gaussian","text":"invert_inverse_gaussian(observations; τ_max, integrator, C0=nothing, \n                       u0=[1e3,1e2], lower=[1.0,12.0], upper=[Inf,Inf],\n                       warmstart=:anneal, sa_iters=50, lbfgs_iters=200)\n\nFit an Inverse Gaussian Transit Time Distribution (TTD) to tracer observations.\n\nMathematical Formulation\n\nEstimates parameters Γ (mean) and Δ (width) of the Inverse Gaussian distribution:\n\nf(τ; Γ, Δ) = √(Δ/(2πτ³)) exp(-(Δ(τ-Γ)²)/(2Γ²τ))\n\nThe optimization solves:\n\nmin_{Γ,Δ} Σᵢⱼ wᵢⱼ(yᵢⱼ - ŷᵢⱼ(Γ,Δ))²\n\nwhere ŷᵢⱼ = ∫₀^τ_max f(τ)·gᵢ(tⱼ-τ)dτ + C0ᵢ is the convolved model prediction.\n\nArguments\n\nobservations: TracerObservation(s) containing times, data, uncertainties, source functions\nτ_max: Maximum transit time for integration (scalar or vector per observation)\nintegrator: Numerical integrator for convolution (scalar or vector per observation)\nC0: Additive constant offset (nothing→0, scalar, or vector per observation)\nu0: Initial parameter guess [Γ₀, Δ₀]\nlower, upper: Parameter bounds\nwarmstart: Use simulated annealing initialization (:anneal or :none)\nsa_iters, lbfgs_iters: Iteration limits for SA and L-BFGS phases\n\nAlgorithm\n\nWarm Start (if :anneal): Log-parameter simulated annealing to improve initial guess\nMain Optimization: Bounded L-BFGS with box constraints via Fminbox\nModel Evaluation: Final parameter estimates used to compute fitted values\n\nReturns\n\nInversionResult containing fitted parameters [Γ̂, Δ̂], observation estimates, and optimizer output.\n\nExample\n\nresult = invert_inverse_gaussian(obs; τ_max=250_000.0, integrator=quad_integrator)\nΓ_fit, Δ_fit = result.parameters\n\n\n\n\n\n","category":"function"},{"location":"#OceanTTDs.Optimizers.max_ent_inversion","page":"Home","title":"OceanTTDs.Optimizers.max_ent_inversion","text":"max_ent_inversion(observations; C0=nothing, prior_distribution, support)\n\nMaximum Entropy inversion for discrete Transit Time Distributions.\n\nMathematical Formulation\n\nThe Maximum Entropy Method solves the constrained optimization problem:\n\nmax S[p] = -Σᵢ pᵢ ln(pᵢ/mᵢ)    (maximize entropy)\nsubject to: Σᵢ pᵢ = 1           (normalization)\n           ||Gp - d||² = χ²     (fit observations)\n\nwhere:\n\np = [p₁, p₂, ..., pₙ] is the discrete TTD probability vector\nm = [m₁, m₂, ..., mₙ] is the prior distribution  \nG is the forward operator (convolution matrix)\nd is the observation vector\nχ² is the target misfit level\n\nThis is solved via Lagrange multipliers, yielding:\n\npᵢ = mᵢ exp(-Σⱼ λⱼ Gⱼᵢ) / Z(λ)\n\nwhere λ = [λ₁, λ₂, ..., λₘ] are Lagrange multipliers found by solving the nonlinear system:\n\n∂S/∂λⱼ = Σᵢ Gⱼᵢ pᵢ(λ) - dⱼ = 0    for j = 1, ..., m\n\nAlgorithm\n\nSetup: Initialize λ = 0 (uniform distribution)\nLevenberg-Marquardt: First-pass nonlinear solver with analytic Jacobian\nTrust Region: Second-pass refinement for improved convergence\nDistribution: Compute final p(λ) and fitted observations\n\nThe analytic Jacobian is:\n\nJⱼₖ = ∂rⱼ/∂λₖ = Ĉₖ Aⱼ - Bⱼₖ\n\nwhere Ĉₖ, Aⱼ, Bⱼₖ involve convolution integrals with the current distribution p(λ).\n\nArguments\n\nobservations: TracerObservation(s) with times, data, source functions\nprior_distribution: Prior probability vector m on support points\nsupport: Discrete transit time support points τ = [τ₁, τ₂, ..., τₙ]\nC0: Additive offset parameter (nothing→0, scalar, or vector)\n\nReturns\n\nInversionResult with λ parameters, discrete TTD probabilities, and solver output.\n\nExample\n\nτ_support = collect(0.0:100.0:10000.0)\nm_prior = ones(length(τ_support)) / length(τ_support)  # uniform prior\nresult = max_ent_inversion(obs; prior_distribution=m_prior, support=τ_support)\nttd_probs = result.distribution\n\n\n\n\n\n","category":"function"},{"location":"#Utility-Functions","page":"Home","title":"Utility Functions","text":"","category":"section"},{"location":"#Distributions.convolve","page":"Home","title":"Distributions.convolve","text":"convolve(TTD, f_src, times; kwargs...)\n\nConvolve a Transit Time Distribution with a source function at observation times.\n\nThis is the main convolution interface used by all optimization methods. Automatically dispatches to the appropriate method based on TTD type:\n\nVector TTD: Direct discrete convolution with τ_support\nDiscrete Distribution: Uses pdf() values with τ_support  \nContinuous Distribution: Numerical integration with integrator\n\nArguments\n\nTTD: Transit time distribution (Vector, DiscreteUnivariateDistribution, or ContinuousUnivariateDistribution)\nf_src: Source function f(t) \ntimes: Vector of observation times\nMethod-specific keywords (see individual methods)\n\nExamples\n\n# Discrete vector convolution (MaxEnt, TCM)\nτs = collect(0:100:10000)\nprobs = [0.1, 0.3, 0.4, 0.2]  # Probability weights\nresult = convolve(probs, f_src, times; τ_support=τs)\n\n# Continuous distribution convolution (Inverse Gaussian)  \ndist = InverseGaussian(μ, λ)\nresult = convolve(dist, f_src, times; τ_max=10000.0, integrator=integrator)\n\n\n\n\n\nconvolve(TTD::Vector, f_src::Function, t_obs::Vector; \n         τ_support::Vector, C0::Real = 0.0)\n\nConvolve discrete TTD probability weights with a source function.\n\nComputes: ŷ(t) = ∑ⱼ TTD[j] * f_src(t - τⱼ) + C0\n\nUsed by MaxEnt and TCM optimization methods.\n\nArguments\n\nTTD: Vector of probability weights/probabilities  \nf_src: Source function f(t)\nt_obs: Observation times\nτ_support: Transit time support points corresponding to TTD entries\nC0: Initial condition - tracer concentration at t=0 (default: 0.0)\n\nReturns\n\nVector of convolution results at each observation time.\n\nExample\n\nτs = collect(1:100) \nTTD_weights = [0.1, 0.3, 0.4, 0.2]  # Discrete probabilities\nf_src = t -> (t >= 0) ? 1.0 : 0.0    # Unit step function\nt_obs = [10.0, 20.0, 30.0]\n\nresult = convolve(TTD_weights, f_src, t_obs; τ_support=τs)\n\n\n\n\n\nconvolve(TTD::DiscreteUnivariateDistribution, f_src::Function, times::Vector;\n         τ_support::Vector, C0 = 0.0)\n\nConvolve discrete distribution with source function using pdf values.\n\nArguments\n\nTTD: Discrete univariate distribution\nf_src: Source function f(t)\ntimes: Vector of observation times\nτ_support: Sorted, non-negative support points for evaluation\nC0: Initial condition - tracer concentration at t=0 (default: 0.0)\n\nReturns\n\nVector with same length as times containing convolution results.\n\n\n\n\n\nconvolve(TTD::ContinuousUnivariateDistribution, f_src::Function, times::Vector;\n         τ_max, integrator, C0 = 0.0)\n\nConvolve continuous distribution with source function using numerical integration.\n\nUsed by Inverse Gaussian optimization method.\n\nArguments\n\nTTD: Continuous univariate distribution\nf_src: Source function f(t)\ntimes: Vector of observation times\nτ_max: Maximum transit time for integration domain [0, τ_max]\nintegrator: Numerical integrator with .nodes and .weights fields\nC0: Initial condition - tracer concentration at t=0 (default: 0.0)\n\nReturns\n\nVector with same length as times containing convolution results.\n\nExample\n\nusing Distributions\ndist = InverseGaussian(300.0, 600.0)  # Mean=300, shape=600\nintegrator = make_gausslegendre_integrator(100, 0.0, 10000.0)\nresult = convolve(dist, f_src, times; τ_max=10000.0, integrator=integrator)\n\n\n\n\n\n","category":"function"},{"location":"#OceanTTDs.tracer_observation","page":"Home","title":"OceanTTDs.tracer_observation","text":"tracer_observation(times, concentrations, source_function; uncertainties=nothing)\n\nCreate a TracerObservation from measurement data.\n\nArguments\n\ntimes: Observation time points\nconcentrations: Measured tracer concentrations  \nsource_function: Boundary condition function f(t) for this tracer\nuncertainties: Measurement uncertainties (optional, defaults to 10% of concentrations)\n\nReturns\n\nTracerObservation object ready for inversion\n\nExample\n\n# CFC-12 with exponential atmospheric growth\ncfc12_source = t -> (t >= 1930) ? exp(0.08 * (t - 1930)) : 0.0\nobs = tracer_observation(times, cfc12_data, cfc12_source)\n\n# Multiple tracers for joint inversion\nobs1 = tracer_observation(times1, cfc11_data, cfc11_source)  \nobs2 = tracer_observation(times2, sf6_data, sf6_source)\nresult = max_ent_inversion([obs1, obs2]; support=τ_support, prior_distribution=prior)\n\n\n\n\n\n","category":"function"},{"location":"#OceanTTDs.uniform_prior","page":"Home","title":"OceanTTDs.uniform_prior","text":"uniform_prior(support)\n\nCreate a uniform prior distribution over the given support points.\n\nArguments\n\nsupport: Transit time support points\n\nReturns\n\nUniform probability vector (all values equal, sum to 1)\n\nExample\n\nτ_support = collect(0:50:2000)\nprior = uniform_prior(τ_support)\nresult = fit_ttd(obs, method=:max_entropy, support=τ_support, prior_distribution=prior)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
