<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · OceanTTDs.jl</title><meta name="title" content="Home · OceanTTDs.jl"/><meta property="og:title" content="Home · OceanTTDs.jl"/><meta property="twitter:title" content="Home · OceanTTDs.jl"/><meta name="description" content="Documentation for OceanTTDs.jl."/><meta property="og:description" content="Documentation for OceanTTDs.jl."/><meta property="twitter:description" content="Documentation for OceanTTDs.jl."/><meta property="og:url" content="https://anthony-meza.github.io/OceanTTDs.jl/"/><meta property="twitter:url" content="https://anthony-meza.github.io/OceanTTDs.jl/"/><link rel="canonical" href="https://anthony-meza.github.io/OceanTTDs.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>OceanTTDs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Features"><span>Features</span></a></li><li><a class="tocitem" href="#Main-Functions"><span>Main Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/anthony-meza/OceanTTDs.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OceanTTDs"><a class="docs-heading-anchor" href="#OceanTTDs">OceanTTDs</a><a id="OceanTTDs-1"></a><a class="docs-heading-anchor-permalink" href="#OceanTTDs" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/anthony-meza/OceanTTDs.jl">OceanTTDs</a>.</p><p><strong>A Julia package for inferring transit-time distribution (TTD) from oceanographic tracer observations</strong></p><h2 id="Features"><a class="docs-heading-anchor" href="#Features">Features</a><a id="Features-1"></a><a class="docs-heading-anchor-permalink" href="#Features" title="Permalink"></a></h2><ul><li><strong>Multiple Inversion Methods</strong>: Inverse Gaussian parameter fitting, Time-Corrected Method (TCM), Maximum Entropy inversion</li><li><strong>Numerical Integration</strong>: Adaptive quadrature methods optimized for convolution operations  </li><li><strong>Statistical Utilities</strong>: Covariance estimation and regularization methods</li></ul><h2 id="Main-Functions"><a class="docs-heading-anchor" href="#Main-Functions">Main Functions</a><a id="Main-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions" title="Permalink"></a></h2><h3 id="Data-Structures"><a class="docs-heading-anchor" href="#Data-Structures">Data Structures</a><a id="Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Structures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.TracerObservations.TracerObservation" href="#OceanTTDs.TracerObservations.TracerObservation"><code>OceanTTDs.TracerObservations.TracerObservation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TracerObservation{T,F&lt;:Function}</code></pre><p>Container for tracer observation data including measurement values, uncertainties, and source functions.</p><p><strong>Fields</strong></p><ul><li><code>t_obs::Vector{T}</code>: Time points of observations</li><li><code>y_obs::Vector{T}</code>: Observed tracer concentrations</li><li><code>σ_obs::Union{Nothing,Vector{T}}</code>: Measurement uncertainties (optional)</li><li><code>f_src::Union{Nothing,F}</code>: Source function for boundary conditions (required for inversion)</li><li><code>nobs::Int</code>: Number of observations</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">TracerObservation(t_obs, y_obs; σ_obs=nothing, f_src=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/TracerObservations.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.InversionResults.InversionResult" href="#OceanTTDs.InversionResults.InversionResult"><code>OceanTTDs.InversionResults.InversionResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InversionResult{T}</code></pre><p>Flexible container for inversion/optimization results that can handle different types of distributions and integration contexts.</p><p><strong>Fields</strong></p><ul><li><code>parameters::AbstractVector</code>: Estimated parameters. Interpretation depends on method:<ul><li><code>:inverse_gaussian</code>: [Γ, Δ] </li><li><code>:inverse_gaussian_equalvars</code>: [Γ]</li><li><code>:max_entropy</code>: <a href="Lagrange multipliers">λ₁, λ₂, ..., λₙ</a></li></ul></li><li><code>obs_estimates::Vector{TracerEstimate{T}}</code>: Updated TracerEstimate objects with predictions</li><li><code>distribution::Union{Distribution, AbstractVector{&lt;:Distribution}, Function, Nothing}</code>: Fitted distribution(s) or template function</li><li><code>integrator::Union{Nothing, Any}</code>: Integration method/context used</li><li><code>support::Union{Nothing, AbstractVector}</code>: Discrete support points if applicable</li><li><code>method::Symbol</code>: Method used (e.g., :inverse<em>gaussian, :max</em>entropy, :inverse<em>gaussian</em>equalvars)</li><li><code>optimizer_output</code>: Raw optimization results from the solver</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/InversionResults.jl#L8-L25">source</a></section></article><h3 id="Optimization-Methods"><a class="docs-heading-anchor" href="#Optimization-Methods">Optimization Methods</a><a id="Optimization-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization-Methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.Optimizers.invert_inverse_gaussian" href="#OceanTTDs.Optimizers.invert_inverse_gaussian"><code>OceanTTDs.Optimizers.invert_inverse_gaussian</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invert_inverse_gaussian(observations; τ_max, integrator, C0=nothing, 
                       u0=[1e3,1e2], lower=[1.0,12.0], upper=[Inf,Inf],
                       warmstart=:anneal, sa_iters=50, lbfgs_iters=200)</code></pre><p>Fit an Inverse Gaussian Transit Time Distribution (TTD) to tracer observations.</p><p><strong>Mathematical Formulation</strong></p><p>Estimates parameters Γ (mean) and Δ (width) of the Inverse Gaussian distribution:</p><pre><code class="nohighlight hljs">f(τ; Γ, Δ) = √(Δ/(2πτ³)) exp(-(Δ(τ-Γ)²)/(2Γ²τ))</code></pre><p>The optimization solves:</p><pre><code class="nohighlight hljs">min_{Γ,Δ} Σᵢⱼ wᵢⱼ(yᵢⱼ - ŷᵢⱼ(Γ,Δ))²</code></pre><p>where <code>ŷᵢⱼ = ∫₀^τ_max f(τ)·gᵢ(tⱼ-τ)dτ + C0ᵢ</code> is the convolved model prediction.</p><p><strong>Arguments</strong></p><ul><li><code>observations</code>: TracerObservation(s) containing times, data, uncertainties, source functions</li><li><code>τ_max</code>: Maximum transit time for integration (scalar or vector per observation)</li><li><code>integrator</code>: Numerical integrator for convolution (scalar or vector per observation)</li><li><code>C0</code>: Additive constant offset (nothing→0, scalar, or vector per observation)</li><li><code>u0</code>: Initial parameter guess [Γ₀, Δ₀]</li><li><code>lower</code>, <code>upper</code>: Parameter bounds</li><li><code>warmstart</code>: Use simulated annealing initialization (<code>:anneal</code> or <code>:none</code>)</li><li><code>sa_iters</code>, <code>lbfgs_iters</code>: Iteration limits for SA and L-BFGS phases</li></ul><p><strong>Algorithm</strong></p><ol><li><strong>Warm Start</strong> (if <code>:anneal</code>): Log-parameter simulated annealing to improve initial guess</li><li><strong>Main Optimization</strong>: Bounded L-BFGS with box constraints via Fminbox</li><li><strong>Model Evaluation</strong>: Final parameter estimates used to compute fitted values</li></ol><p><strong>Returns</strong></p><p>InversionResult containing fitted parameters [Γ̂, Δ̂], observation estimates, and optimizer output.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = invert_inverse_gaussian(obs; τ_max=250_000.0, integrator=quad_integrator)
Γ_fit, Δ_fit = result.parameters</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Optimizers/InverseGaussian.jl#L24-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.Optimizers.max_ent_inversion" href="#OceanTTDs.Optimizers.max_ent_inversion"><code>OceanTTDs.Optimizers.max_ent_inversion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">max_ent_inversion(observations; C0=nothing, prior_distribution, support)</code></pre><p>Maximum Entropy inversion for discrete Transit Time Distributions.</p><p><strong>Mathematical Formulation</strong></p><p>The Maximum Entropy Method solves the constrained optimization problem:</p><pre><code class="nohighlight hljs">max S[p] = -Σᵢ pᵢ ln(pᵢ/mᵢ)    (maximize entropy)
subject to: Σᵢ pᵢ = 1           (normalization)
           ||Gp - d||² = χ²     (fit observations)</code></pre><p>where:</p><ul><li><code>p = [p₁, p₂, ..., pₙ]</code> is the discrete TTD probability vector</li><li><code>m = [m₁, m₂, ..., mₙ]</code> is the prior distribution  </li><li><code>G</code> is the forward operator (convolution matrix)</li><li><code>d</code> is the observation vector</li><li><code>χ²</code> is the target misfit level</li></ul><p>This is solved via Lagrange multipliers, yielding:</p><pre><code class="nohighlight hljs">pᵢ = mᵢ exp(-Σⱼ λⱼ Gⱼᵢ) / Z(λ)</code></pre><p>where λ = [λ₁, λ₂, ..., λₘ] are Lagrange multipliers found by solving the nonlinear system:</p><pre><code class="nohighlight hljs">∂S/∂λⱼ = Σᵢ Gⱼᵢ pᵢ(λ) - dⱼ = 0    for j = 1, ..., m</code></pre><p><strong>Algorithm</strong></p><ol><li><strong>Setup</strong>: Initialize λ = 0 (uniform distribution)</li><li><strong>Levenberg-Marquardt</strong>: First-pass nonlinear solver with analytic Jacobian</li><li><strong>Trust Region</strong>: Second-pass refinement for improved convergence</li><li><strong>Distribution</strong>: Compute final p(λ) and fitted observations</li></ol><p>The analytic Jacobian is:</p><pre><code class="nohighlight hljs">Jⱼₖ = ∂rⱼ/∂λₖ = Ĉₖ Aⱼ - Bⱼₖ</code></pre><p>where Ĉₖ, Aⱼ, Bⱼₖ involve convolution integrals with the current distribution p(λ).</p><p><strong>Arguments</strong></p><ul><li><code>observations</code>: TracerObservation(s) with times, data, source functions</li><li><code>prior_distribution</code>: Prior probability vector m on support points</li><li><code>support</code>: Discrete transit time support points τ = [τ₁, τ₂, ..., τₙ]</li><li><code>C0</code>: Additive offset parameter (nothing→0, scalar, or vector)</li></ul><p><strong>Returns</strong></p><p>InversionResult with λ parameters, discrete TTD probabilities, and solver output.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">τ_support = collect(0.0:100.0:10000.0)
m_prior = ones(length(τ_support)) / length(τ_support)  # uniform prior
result = max_ent_inversion(obs; prior_distribution=m_prior, support=τ_support)
ttd_probs = result.distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Optimizers/MaximumEntropy.jl#L10-L73">source</a></section></article><h3 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Distributions.convolve" href="#Distributions.convolve"><code>Distributions.convolve</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convolve(TTD, f_src, times; kwargs...)</code></pre><p>Convolve a Transit Time Distribution with a source function at observation times.</p><p>This is the main convolution interface used by all optimization methods. Automatically dispatches to the appropriate method based on TTD type:</p><ul><li><strong>Vector TTD</strong>: Direct discrete convolution with τ_support</li><li><strong>Discrete Distribution</strong>: Uses pdf() values with τ_support  </li><li><strong>Continuous Distribution</strong>: Numerical integration with integrator</li></ul><p><strong>Arguments</strong></p><ul><li><code>TTD</code>: Transit time distribution (Vector, DiscreteUnivariateDistribution, or ContinuousUnivariateDistribution)</li><li><code>f_src</code>: Source function f(t) </li><li><code>times</code>: Vector of observation times</li><li>Method-specific keywords (see individual methods)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Discrete vector convolution (MaxEnt, TCM)
τs = collect(0:100:10000)
probs = [0.1, 0.3, 0.4, 0.2]  # Probability weights
result = convolve(probs, f_src, times; τ_support=τs)

# Continuous distribution convolution (Inverse Gaussian)  
dist = InverseGaussian(μ, λ)
result = convolve(dist, f_src, times; τ_max=10000.0, integrator=integrator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Convolution.jl#L9-L38">source</a></section><section><div><pre><code class="language-julia hljs">convolve(TTD::Vector, f_src::Function, t_obs::Vector; 
         τ_support::Vector, C0::Real = 0.0)</code></pre><p>Convolve discrete TTD probability weights with a source function.</p><p>Computes: ŷ(t) = ∑ⱼ TTD[j] * f_src(t - τⱼ) + C0</p><p>Used by MaxEnt and TCM optimization methods.</p><p><strong>Arguments</strong></p><ul><li><code>TTD</code>: Vector of probability weights/probabilities  </li><li><code>f_src</code>: Source function f(t)</li><li><code>t_obs</code>: Observation times</li><li><code>τ_support</code>: Transit time support points corresponding to TTD entries</li><li><code>C0</code>: Initial condition - tracer concentration at t=0 (default: 0.0)</li></ul><p><strong>Returns</strong></p><p>Vector of convolution results at each observation time.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">τs = collect(1:100) 
TTD_weights = [0.1, 0.3, 0.4, 0.2]  # Discrete probabilities
f_src = t -&gt; (t &gt;= 0) ? 1.0 : 0.0    # Unit step function
t_obs = [10.0, 20.0, 30.0]

result = convolve(TTD_weights, f_src, t_obs; τ_support=τs)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Convolution.jl#L58-L87">source</a></section><section><div><pre><code class="language-julia hljs">convolve(TTD::DiscreteUnivariateDistribution, f_src::Function, times::Vector;
         τ_support::Vector, C0 = 0.0)</code></pre><p>Convolve discrete distribution with source function using pdf values.</p><p><strong>Arguments</strong></p><ul><li><code>TTD</code>: Discrete univariate distribution</li><li><code>f_src</code>: Source function f(t)</li><li><code>times</code>: Vector of observation times</li><li><code>τ_support</code>: Sorted, non-negative support points for evaluation</li><li><code>C0</code>: Initial condition - tracer concentration at t=0 (default: 0.0)</li></ul><p><strong>Returns</strong></p><p>Vector with same length as <code>times</code> containing convolution results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Convolution.jl#L126-L141">source</a></section><section><div><pre><code class="language-julia hljs">convolve(TTD::ContinuousUnivariateDistribution, f_src::Function, times::Vector;
         τ_max, integrator, C0 = 0.0)</code></pre><p>Convolve continuous distribution with source function using numerical integration.</p><p>Used by Inverse Gaussian optimization method.</p><p><strong>Arguments</strong></p><ul><li><code>TTD</code>: Continuous univariate distribution</li><li><code>f_src</code>: Source function f(t)</li><li><code>times</code>: Vector of observation times</li><li><code>τ_max</code>: Maximum transit time for integration domain [0, τ_max]</li><li><code>integrator</code>: Numerical integrator with <code>.nodes</code> and <code>.weights</code> fields</li><li><code>C0</code>: Initial condition - tracer concentration at t=0 (default: 0.0)</li></ul><p><strong>Returns</strong></p><p>Vector with same length as <code>times</code> containing convolution results.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Distributions
dist = InverseGaussian(300.0, 600.0)  # Mean=300, shape=600
integrator = make_gausslegendre_integrator(100, 0.0, 10000.0)
result = convolve(dist, f_src, times; τ_max=10000.0, integrator=integrator)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/Convolution.jl#L185-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.tracer_observation" href="#OceanTTDs.tracer_observation"><code>OceanTTDs.tracer_observation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tracer_observation(times, concentrations, source_function; uncertainties=nothing)</code></pre><p>Create a TracerObservation from measurement data.</p><p><strong>Arguments</strong></p><ul><li><code>times</code>: Observation time points</li><li><code>concentrations</code>: Measured tracer concentrations  </li><li><code>source_function</code>: Boundary condition function f(t) for this tracer</li><li><code>uncertainties</code>: Measurement uncertainties (optional, defaults to 10% of concentrations)</li></ul><p><strong>Returns</strong></p><p>TracerObservation object ready for inversion</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># CFC-12 with exponential atmospheric growth
cfc12_source = t -&gt; (t &gt;= 1930) ? exp(0.08 * (t - 1930)) : 0.0
obs = tracer_observation(times, cfc12_data, cfc12_source)

# Multiple tracers for joint inversion
obs1 = tracer_observation(times1, cfc11_data, cfc11_source)  
obs2 = tracer_observation(times2, sf6_data, sf6_source)
result = max_ent_inversion([obs1, obs2]; support=τ_support, prior_distribution=prior)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/OceanTTDs.jl#L35-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OceanTTDs.uniform_prior" href="#OceanTTDs.uniform_prior"><code>OceanTTDs.uniform_prior</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_prior(support)</code></pre><p>Create a uniform prior distribution over the given support points.</p><p><strong>Arguments</strong></p><ul><li><code>support</code>: Transit time support points</li></ul><p><strong>Returns</strong></p><p>Uniform probability vector (all values equal, sum to 1)</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">τ_support = collect(0:50:2000)
prior = uniform_prior(τ_support)
result = fit_ttd(obs, method=:max_entropy, support=τ_support, prior_distribution=prior)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/anthony-meza/OceanTTDs.jl/blob/7188ddaf3e8d84b3e6f937e78276411b2af50db8/src/OceanTTDs.jl#L69-L86">source</a></section></article><ul><li><a href="#OceanTTDs.InversionResults.InversionResult"><code>OceanTTDs.InversionResults.InversionResult</code></a></li><li><a href="#OceanTTDs.TracerObservations.TracerObservation"><code>OceanTTDs.TracerObservations.TracerObservation</code></a></li><li><a href="#Distributions.convolve"><code>Distributions.convolve</code></a></li><li><a href="#OceanTTDs.Optimizers.invert_inverse_gaussian"><code>OceanTTDs.Optimizers.invert_inverse_gaussian</code></a></li><li><a href="#OceanTTDs.Optimizers.max_ent_inversion"><code>OceanTTDs.Optimizers.max_ent_inversion</code></a></li><li><a href="#OceanTTDs.tracer_observation"><code>OceanTTDs.tracer_observation</code></a></li><li><a href="#OceanTTDs.uniform_prior"><code>OceanTTDs.uniform_prior</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 28 August 2025 18:15">Thursday 28 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
